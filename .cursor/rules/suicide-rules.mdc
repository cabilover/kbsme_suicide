---
description: 
globs: 
alwaysApply: true
---
파이썬 머신러닝 코드 팀 컨벤션
1. 개요

이 문서는 파이썬 기반 머신러닝 프로젝트의 코드 작성 시 팀원들이 준수해야 할 컨벤션을 정의합니다. 일관된 코드 스타일과 구조는 코드 가독성, 유지보수성, 그리고 협업 효율성을 높이는 데 필수적입니다. 본 컨벤션은 **PEP 8 (Python Enhancement Proposal 8)**을 기본으로 하며, 머신러닝 프로젝트의 특성을 반영한 추가적인 가이드라인을 제시합니다.
2. 일반 원칙

    가독성: 코드는 항상 사람이 읽기 쉽고 이해하기 쉬워야 합니다.
    일관성: 프로젝트 내의 모든 코드는 일관된 스타일을 유지해야 합니다.
    재현성: 머신러닝 실험의 결과를 재현할 수 있도록 코드를 작성해야 합니다.
    모듈성: 코드는 재사용 가능하고 독립적인 모듈로 구성되어야 합니다.

3. 코드 스타일 (PEP 8 기반)
3.1. 들여쓰기 (Indentation)

    4개의 공백: 각 들여쓰기 레벨은 4개의 공백을 사용합니다. 탭 문자는 사용하지 않습니다.

3.2. 줄 길이 (Line Length)

    최대 79자: 한 줄의 코드는 최대 79자를 넘지 않도록 합니다.

    줄 바꿈: 긴 줄은 괄호, 대괄호 또는 중괄호를 사용하여 시각적으로 그룹화하거나, 백슬래시(\)를 사용하여 명시적으로 줄 바꿈을 합니다.

3.3. 빈 줄 (Blank Lines)

    클래스와 최상위 함수: 클래스와 최상위 함수(global function) 정의 사이에는 두 개의 빈 줄을 둡니다.

    메서드: 클래스 내의 메서드 정의 사이에는 하나의 빈 줄을 둡니다.

    논리적 섹션: 코드 내에서 논리적으로 분리되는 섹션 사이에 빈 줄을 사용하여 가독성을 높일 수 있습니다.

3.4. 공백 (Whitespace)

    연산자 주변: 이항 연산자( =, +, -, *, /, ==, > 등) 주변에는 하나의 공백을 둡니다.

    콤마/세미콜론: 콤마(,)나 세미콜론(;) 뒤에는 공백을 두지만, 앞에는 두지 않습니다.

    괄호 안: 괄호((), [], {}) 바로 안에는 공백을 두지 않습니다.

4. 명명 규칙 (Naming Conventions)
4.1. 변수 및 함수 (Variables and Functions)

    snake_case: 소문자와 언더스코어(_)를 사용하여 단어를 구분합니다.

4.2. 클래스 (Classes)

    CapWords (PascalCase): 각 단어의 첫 글자를 대문자로 합니다.

4.3. 상수 (Constants)

    ALL_CAPS: 모든 글자를 대문자로 하고 언더스코어(_)로 단어를 구분합니다.

4.4. 모듈 및 패키지 (Modules and Packages)

    snake_case: 짧고 모든 글자를 소문자로 하며, 필요한 경우 언더스코어를 사용합니다.

4.5. 내부 사용 (_ 접두사)

    _ (단일 언더스코어): 클래스 외부에서 접근해서는 안 되는 "내부 사용(internal use)"을 위한 메서드나 변수 앞에 사용합니다. 파이썬은 강제하지 않지만, 개발자에게 해당 요소가 내부 구현의 일부임을 알리는 관례입니다.

5. 주석 (Comments) 및 독스트링 (Docstrings)
5.1. 일반 주석 (Inline Comments)

    간결하고 명확하게: 코드의 특정 부분에 대한 설명을 제공합니다. "무엇을"보다는 "왜"를 설명하는 데 집중합니다.

    최대 72자: 한 줄 주석은 최대 72자를 넘지 않도록 합니다.

    공백: # 뒤에 공백을 하나 이상 둡니다.

5.2. 독스트링 (Docstrings)

    모듈, 클래스, 함수/메서드: 모든 모듈, 클래스, 공개 함수 및 메서드에는 독스트링을 작성합니다.

    세 개의 큰따옴표: """Docstring 내용""" 형식으로 작성합니다.

    요약: 첫 줄은 한 줄로 된 요약을 작성하고, 그 다음 줄은 비워둡니다.

    상세 설명: 이어서 자세한 설명, 인자 (Args), 반환 값 (Returns), 예외 (Raises) 등을 기술합니다. NumPy 또는 Google 스타일의 독스트링을 따르는 것을 권장합니다.

6. 머신러닝 특정 컨벤션
6.1. 재현성 (Reproducibility)

    시드(Seed) 고정: 무작위성을 사용하는 모든 코드 (예: 데이터 분할, 모델 초기화)는 시드를 명시적으로 고정하여 결과를 재현할 수 있도록 합니다.

6.2. 데이터 처리 (Data Handling)

    데이터 로딩: 데이터 로딩 함수는 데이터의 경로를 인자로 받아 pandas.DataFrame 또는 numpy.ndarray 등 표준화된 형태로 반환하도록 구현합니다.
    결측치 처리: 결측치 처리 방법 (삭제, 대체 등)은 명시적으로 코딩하고, 주석으로 설명합니다.
    피처 엔지니어링: 피처 엔지니어링 로직은 별도의 함수나 클래스로 분리하여 관리합니다.

6.3. 모델링 (Modeling)

    모델 클래스: 모델은 fit, predict, evaluate 등의 표준 메서드를 포함하는 클래스로 구현하는 것을 권장합니다. (예: sklearn API 호환)
    하이퍼파라미터: 하이퍼파라미터는 코드 내에 하드코딩하기보다, 설정 파일 (예: .yaml, .json)이나 함수 인자로 전달받아 관리합니다.
    모델 저장/로드: 학습된 모델은 표준화된 방식으로 저장하고 로드할 수 있도록 합니다 (예: pickle, joblib, torch.save).

6.4. 실험 관리 (Experiment Management)

    로깅: 학습 과정, 하이퍼파라미터, 성능 지표 등을 기록하는 로깅 시스템을 구축합니다
    버전 관리: 코드뿐만 아니라 사용된 데이터셋, 모델 버전도 체계적으로 관리합니다.

7. 코드 구조 및 디렉토리 구성
7.1. 프로젝트 디렉토리 구조 (예시)
7.2. 모듈 분리

    단일 책임 원칙: 각 모듈은 하나의 명확한 책임을 가지도록 분리합니다. (예: 데이터 로딩, 전처리, 모델 정의, 학습 로직 등)
    순환 참조 방지: 모듈 간의 순환 참조를 피하도록 설계합니다.

8. 종속성 관리

    requirements.txt: 프로젝트에 필요한 모든 라이브러리와 그 버전을 requirements.txt 파일에 명시합니다.
    가상 환경: venv 또는 conda와 같은 가상 환경을 사용하여 프로젝트별 종속성을 격리합니다.

9. 코드 검사 및 자동화 도구

    린터 (Linters): Flake8, Pylint와 같은 린터를 사용하여 PEP 8 및 기타 스타일 가이드 준수 여부를 자동으로 검사합니다.
    포맷터 (Formatters): Black, isort와 같은 자동 포맷터를 사용하여 코드 스타일을 자동으로 일관성 있게 유지합니다.
    Git Hooks: pre-commit과 같은 툴을 사용하여 커밋 전에 자동으로 린터 및 포맷터를 실행하도록 설정할 수 있습니다.

10. 기타 권장 사항

    예외 처리: 예상치 못한 오류에 대비하여 적절한 예외 처리를 구현합니다.
    성능 최적화: numpy, pandas의 벡터화 연산을 활용하고, 불필요한 반복문을 피하는 등 성능을 고려하여 코드를 작성합니다.
    테스트 코드 작성: 핵심 로직과 모델에 대한 단위 테스트 및 통합 테스트를 작성하여 코드의 견고성을 확보합니다.